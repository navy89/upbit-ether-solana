<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>솔라나-이더리움 가격 추적기</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #05070d;
            --bg-elev: #0b1020;
            --bg-card: #111a2f;
            --bg-soft: #16213d;
            --line: rgba(141, 167, 255, 0.22);
            --line-strong: rgba(93, 220, 255, 0.55);
            --text: #f4f7ff;
            --text-sub: #95a2c7;
            --buy: #25e6a3;
            --sell: #ff6a8a;
            --accent: #54b8ff;
            --accent-2: #7d8bff;
            --warn: #ffd56a;
            --accent-blue: #54b8ff;
            --accent-green: #25e6a3;
            --accent-red: #ff6a8a;
            --accent-yellow: #ffd56a;
            --text-primary: #f4f7ff;
            --text-secondary: #95a2c7;
            --border: rgba(141, 167, 255, 0.22);
        }

        body {
            font-family: 'Inter', sans-serif;
            color: var(--text);
            min-height: 100vh;
            background:
                radial-gradient(1200px 500px at 10% -20%, rgba(84,184,255,0.18), transparent),
                radial-gradient(900px 420px at 90% -10%, rgba(125,139,255,0.2), transparent),
                linear-gradient(160deg, #05070d 0%, #080c17 45%, #04060d 100%);
            overflow-x: hidden;
        }

        .container {
            max-width: 1700px;
            margin: 0 auto;
            min-height: 100vh;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.8rem;
            border: 1px solid var(--line);
            border-radius: 14px;
            padding: 0.9rem 1rem;
            background: linear-gradient(140deg, rgba(17,26,47,0.88), rgba(11,16,32,0.92));
            box-shadow: 0 14px 28px rgba(4, 6, 14, 0.45);
        }

        h1 {
            font-size: 1.15rem;
            letter-spacing: 0.02em;
            font-weight: 800;
        }

        .subtitle { font-size: 0.72rem; color: var(--text-sub); margin-top: 0.2rem; }

        .header-pill {
            border: 1px solid var(--line-strong);
            color: #caf2ff;
            font-size: 0.7rem;
            font-weight: 700;
            padding: 0.35rem 0.6rem;
            border-radius: 999px;
            background: rgba(84, 184, 255, 0.15);
            white-space: nowrap;
        }

        .main-grid {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 0.7rem;
            flex: 1;
            min-height: 0;
        }

        .card {
            background: linear-gradient(160deg, rgba(17,26,47,0.92), rgba(11,16,32,0.95));
            border: 1px solid var(--line);
            border-radius: 12px;
            padding: 0.75rem;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.04), 0 10px 20px rgba(2,4,10,0.4);
        }

        .main-grid > .card:nth-child(1) { grid-column: span 4; }
        .main-grid > .card:nth-child(2) { grid-column: span 2; }
        .main-grid > .card:nth-child(3) { grid-column: span 3; }
        .main-grid > .card:nth-child(4) { grid-column: span 3; }
        .main-grid > .card:nth-child(5) { grid-column: span 2; }
        .main-grid > .card:nth-child(6) { grid-column: span 2; }
        .main-grid > .card:nth-child(7) { grid-column: span 2; }
        .chart-card { grid-column: 1 / -1; }

        .card-title {
            font-size: 0.64rem;
            color: #b3c1e7;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            margin-bottom: 0.55rem;
            font-weight: 700;
        }

        .coin-grid { display: grid; gap: 0.45rem; flex: 1; }
        .coin-item {
            background: linear-gradient(145deg, rgba(23,33,58,0.9), rgba(16,23,42,0.85));
            padding: 0.52rem;
            border-radius: 8px;
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 0.5rem;
            align-items: center;
            border: 1px solid rgba(132, 155, 224, 0.2);
        }
        .coin-name { font-size: 0.68rem; font-weight: 700; color: #c6d1f2; }
        .coin-price { font-size: 0.86rem; font-weight: 800; text-align: right; }

        .coin-price.flash-up, .diff-value.flash-up { animation: flashUp 0.4s ease; }
        .coin-price.flash-down, .diff-value.flash-down { animation: flashDown 0.4s ease; }
        @keyframes flashUp { 50% { color: var(--buy); text-shadow: 0 0 10px rgba(37,230,163,.55);} }
        @keyframes flashDown { 50% { color: var(--sell); text-shadow: 0 0 10px rgba(255,106,138,.5);} }

        .coin-change { font-size: 0.65rem; font-weight: 700; padding: 0.16rem 0.35rem; border-radius: 4px; }
        .change-positive { background: rgba(37,230,163,0.14); color: var(--buy); }
        .change-negative { background: rgba(255,106,138,0.15); color: var(--sell); }

        .input-card { border-color: rgba(37,230,163,0.45); background: linear-gradient(150deg, rgba(12,32,35,.95), rgba(14,24,35,.95)); justify-content: center; gap: .5rem; }
        .eth-input { background: rgba(255,255,255,.06); border: 1px solid var(--line); border-radius: 7px; padding: .5rem; color: var(--text); text-align:center; font-size:1.1rem; font-weight:700; }
        .eth-input:focus { outline:none; border-color: var(--buy); }
        .input-label { font-size:.68rem; color: var(--text-sub); }

        .fee-grid { display:grid; gap:.4rem; }
        .fee-item, .stat-row {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(143,166,232,.16);
            border-radius: 6px;
            padding: .42rem;
        }
        .fee-item { display:flex; justify-content:space-between; align-items:center; gap:.5rem; }
        .fee-label { font-size:.63rem; color: var(--text-sub); }
        .fee-value { font-size:.74rem; font-weight:700; }
        .stats-card { gap:.3rem; }
        .stat-period { font-size:.55rem; color:#8cc7ff; text-transform:uppercase; letter-spacing:.08em; font-weight:700; margin-top:.25rem; }
        .stat-value { font-size:.69rem; font-weight:700; }
        .stat-time { font-size:.52rem; color: var(--text-sub); }

        .diff-value { font-size:1.5rem; font-weight:800; }
        .diff-label { font-size:.63rem; color: var(--text-sub); }

        .chart-info { display:flex; gap:1rem; padding:0.4rem 0; margin-bottom:0.4rem; font-size:.72rem; border-bottom:1px solid var(--line); min-height:30px; align-items:center; }
        .chart-info-label, .chart-info-placeholder { color: var(--text-sub); }
        .chart-info-value { font-weight:700; }
        .chart-container { position:relative; flex:1; min-height:0; }
        .chart-svg { width:100%; height:100%; display:block; }
        .crosshair-line { pointer-events:none; }

        .status {
            position: fixed;
            bottom: 0.55rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items:center;
            gap: .65rem;
            background: rgba(11,16,32,0.94);
            border: 1px solid var(--line);
            border-radius: 999px;
            padding: .45rem .8rem;
            font-size: .6rem;
            color: var(--text-sub);
            backdrop-filter: blur(10px);
        }
        .status-dot { width:6px;height:6px;border-radius:50%;background:var(--buy);animation:pulse 1.8s infinite; }
        @keyframes pulse { 50% { opacity: .35; } }

        .loading { display:flex; align-items:center; justify-content:center; min-height:100vh; color:var(--text-sub); }

        @media (max-width: 1200px) {
            .main-grid { grid-template-columns: repeat(2, 1fr); }
            .main-grid > .card { grid-column: span 1 !important; }
            .chart-card { grid-column: 1 / -1 !important; }
        }

        @media (max-width: 768px) {
            .container { padding: .55rem; }
            .header { flex-direction: column; align-items: flex-start; }
            .main-grid { grid-template-columns: 1fr; }
            .card { padding: .62rem; }
            .chart-card { margin: 0 -0.55rem; border-radius: 0; width: calc(100% + 1.1rem); }
            .chart-svg { min-height: 250px; }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function CandlestickChart({ data, onHover }) {
            const svgRef = useRef(null);
            const containerRef = useRef(null);
            const [isTouching, setIsTouching] = useState(false);

            useEffect(() => {
                if (!data || data.length === 0 || !svgRef.current || !containerRef.current) return;

                const container = containerRef.current;
                const svg = svgRef.current;
                const width = container.clientWidth;
                const height = 300;
                
                svg.innerHTML = '';
                svg.setAttribute('width', width);
                svg.setAttribute('height', height);
                svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

                const isMobile = width < 768;
                const padding = isMobile 
                    ? { top: 20, right: 10, bottom: 60, left: 10 }
                    : { top: 20, right: 50, bottom: 50, left: 60 };
                
                const chartWidth = width - padding.left - padding.right;
                const chartHeight = height - padding.top - padding.bottom;

                const allValues = data.flatMap(d => [d.o, d.c]);
                const minValue = Math.min(...allValues);
                const maxValue = Math.max(...allValues);
                const valueRange = maxValue - minValue;

                const yScale = (value) => {
                    return padding.top + chartHeight - ((value - minValue) / valueRange) * chartHeight;
                };

                const candleWidth = Math.max(2, chartWidth / data.length * 0.8);
                const candleGap = chartWidth / data.length;

                // Y축 그리드
                const gridCount = isMobile ? 4 : 5;
                for (let i = 0; i <= gridCount; i++) {
                    const y = padding.top + (chartHeight / gridCount) * i;
                    const value = maxValue - (valueRange / gridCount) * i;
                    
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', padding.left);
                    line.setAttribute('y1', y);
                    line.setAttribute('x2', width - padding.right);
                    line.setAttribute('y2', y);
                    line.setAttribute('stroke', 'rgba(255,255,255,0.05)');
                    svg.appendChild(line);

                    if (!isMobile) {
                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('x', width - padding.right + 5);
                        text.setAttribute('y', y + 4);
                        text.setAttribute('fill', '#8a8a9f');
                        text.setAttribute('font-size', '10');
                        text.textContent = '₩' + Math.round(value).toLocaleString();
                        svg.appendChild(text);
                    }
                }

                // X축 날짜 라벨
                const dateMap = new Map();
                data.forEach((candle, i) => {
                    const date = new Date(candle.x);
                    const dateKey = `${date.getMonth()+1}/${date.getDate()}`;
                    
                    if (!dateMap.has(dateKey)) {
                        dateMap.set(dateKey, i);
                    }
                });

                // 모바일에서는 날짜 간격을 넓게
                const dateEntries = Array.from(dateMap.entries());
                const dateStep = isMobile ? Math.ceil(dateEntries.length / 4) : 1;
                
                dateEntries.forEach(([dateLabel, index], i) => {
                    if (i % dateStep !== 0 && i !== dateEntries.length - 1) return;
                    
                    const x = padding.left + candleGap * index + candleGap / 2;
                    
                    const dateText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    dateText.setAttribute('x', x);
                    dateText.setAttribute('y', height - padding.bottom + 20);
                    dateText.setAttribute('fill', '#8a8a9f');
                    dateText.setAttribute('font-size', isMobile ? '11' : '10');
                    dateText.setAttribute('text-anchor', 'middle');
                    dateText.textContent = dateLabel;
                    svg.appendChild(dateText);
                    
                    const dateLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    dateLine.setAttribute('x1', x);
                    dateLine.setAttribute('y1', padding.top);
                    dateLine.setAttribute('x2', x);
                    dateLine.setAttribute('y2', height - padding.bottom);
                    dateLine.setAttribute('stroke', 'rgba(255,255,255,0.08)');
                    dateLine.setAttribute('stroke-dasharray', '2,3');
                    svg.appendChild(dateLine);
                });

                // 크로스헤어 라인들
                const verticalLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                verticalLine.setAttribute('stroke', '#9945ff');
                verticalLine.setAttribute('stroke-width', isMobile ? '2' : '1');
                verticalLine.setAttribute('stroke-dasharray', '4,4');
                verticalLine.setAttribute('opacity', '0');
                verticalLine.setAttribute('y1', padding.top);
                verticalLine.setAttribute('y2', height - padding.bottom);
                verticalLine.setAttribute('pointer-events', 'none');
                svg.appendChild(verticalLine);

                const horizontalLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                horizontalLine.setAttribute('stroke', '#9945ff');
                horizontalLine.setAttribute('stroke-width', isMobile ? '2' : '1');
                horizontalLine.setAttribute('stroke-dasharray', '4,4');
                horizontalLine.setAttribute('opacity', '0');
                horizontalLine.setAttribute('x1', padding.left);
                horizontalLine.setAttribute('x2', width - padding.right);
                horizontalLine.setAttribute('pointer-events', 'none');
                svg.appendChild(horizontalLine);

                // 호버 정보 텍스트
                const hoverDateText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                hoverDateText.setAttribute('fill', '#9945ff');
                hoverDateText.setAttribute('font-size', isMobile ? '12' : '11');
                hoverDateText.setAttribute('font-weight', '700');
                hoverDateText.setAttribute('text-anchor', 'middle');
                hoverDateText.setAttribute('opacity', '0');
                hoverDateText.setAttribute('y', height - padding.bottom + 45);
                hoverDateText.setAttribute('pointer-events', 'none');
                svg.appendChild(hoverDateText);

                if (!isMobile) {
                    const priceText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    priceText.setAttribute('fill', '#9945ff');
                    priceText.setAttribute('font-size', '11');
                    priceText.setAttribute('font-weight', '700');
                    priceText.setAttribute('text-anchor', 'end');
                    priceText.setAttribute('opacity', '0');
                    priceText.setAttribute('x', padding.left - 5);
                    priceText.setAttribute('pointer-events', 'none');
                    svg.appendChild(priceText);
                }

                // 크로스헤어 업데이트 함수
                const updateCrosshair = (clientX) => {
                    const rect = svg.getBoundingClientRect();
                    const x = clientX - rect.left;
                    
                    if (x < padding.left || x > width - padding.right) {
                        return;
                    }

                    const index = Math.floor((x - padding.left) / candleGap);
                    if (index < 0 || index >= data.length) return;

                    const candle = data[index];
                    const candleX = padding.left + candleGap * index + candleGap / 2;
                    const yClose = yScale(candle.c);

                    verticalLine.setAttribute('x1', candleX);
                    verticalLine.setAttribute('x2', candleX);
                    verticalLine.setAttribute('opacity', '0.8');

                    horizontalLine.setAttribute('y1', yClose);
                    horizontalLine.setAttribute('y2', yClose);
                    horizontalLine.setAttribute('opacity', '0.8');

                    const date = new Date(candle.x);
                    hoverDateText.textContent = `${date.getMonth()+1}/${date.getDate()} ${String(date.getHours()).padStart(2,'0')}:00 - ₩${Math.round(candle.c).toLocaleString()}`;
                    hoverDateText.setAttribute('x', width / 2);
                    hoverDateText.setAttribute('opacity', '1');

                    if (!isMobile && svg.querySelector('text[text-anchor="end"]')) {
                        const priceText = svg.querySelector('text[text-anchor="end"]');
                        priceText.textContent = '₩' + Math.round(candle.c).toLocaleString();
                        priceText.setAttribute('y', yClose + 4);
                        priceText.setAttribute('opacity', '1');
                    }

                    onHover(candle);
                };

                const hideCrosshair = () => {
                    verticalLine.setAttribute('opacity', '0');
                    horizontalLine.setAttribute('opacity', '0');
                    hoverDateText.setAttribute('opacity', '0');
                    if (!isMobile && svg.querySelector('text[text-anchor="end"]')) {
                        svg.querySelector('text[text-anchor="end"]').setAttribute('opacity', '0');
                    }
                    onHover(null);
                };

                // 캔들 그리기
                data.forEach((candle, i) => {
                    const x = padding.left + candleGap * i + (candleGap - candleWidth) / 2;
                    const yOpen = yScale(candle.o);
                    const yClose = yScale(candle.c);

                    const isUp = candle.c >= candle.o;
                    const color = isUp ? '#00ff88' : '#ff3366';

                    const bodyHeight = Math.abs(yClose - yOpen) || 1;
                    const bodyY = Math.min(yOpen, yClose);
                    
                    const body = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    body.setAttribute('x', x);
                    body.setAttribute('y', bodyY);
                    body.setAttribute('width', candleWidth);
                    body.setAttribute('height', bodyHeight);
                    body.setAttribute('fill', color);
                    body.setAttribute('pointer-events', 'none');
                    svg.appendChild(body);
                });

                // 투명 오버레이
                const overlay = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                overlay.setAttribute('x', 0);
                overlay.setAttribute('y', 0);
                overlay.setAttribute('width', width);
                overlay.setAttribute('height', height);
                overlay.setAttribute('fill', 'transparent');
                overlay.setAttribute('cursor', 'crosshair');

                // 마우스 이벤트
                overlay.addEventListener('mouseenter', (e) => {
                    if (!isMobile) updateCrosshair(e.clientX);
                });

                overlay.addEventListener('mousemove', (e) => {
                    if (!isMobile) updateCrosshair(e.clientX);
                });

                overlay.addEventListener('mouseleave', () => {
                    if (!isTouching && !isMobile) hideCrosshair();
                });

                // 터치 이벤트
                overlay.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    setIsTouching(true);
                    const touch = e.touches[0];
                    updateCrosshair(touch.clientX);
                }, { passive: false });

                overlay.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    updateCrosshair(touch.clientX);
                }, { passive: false });

                overlay.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    setTimeout(() => {
                        setIsTouching(false);
                        hideCrosshair();
                    }, 1500);
                }, { passive: false });

                overlay.addEventListener('touchcancel', () => {
                    setIsTouching(false);
                    hideCrosshair();
                });

                svg.appendChild(overlay);

            }, [data, onHover, isTouching]);

            return (
                <div ref={containerRef} style={{ width: '100%', height: '100%', minHeight: '300px' }}>
                    <svg ref={svgRef} className="chart-svg" style={{ display: 'block' }}></svg>
                </div>
            );
        }

        function App() {
            const [prices, setPrices] = useState({ eth: null, sol: null, btc: null });
            const [dayChanges, setDayChanges] = useState({ eth: 0, sol: 0, btc: 0 });
            const [stats24h, setStats24h] = useState(null);
            const [stats7d, setStats7d] = useState(null);
            const [chartData, setChartData] = useState([]);
            const [hourlyData, setHourlyData] = useState([]);
            const [hoverData, setHoverData] = useState(null);
            const [loading, setLoading] = useState(true);
            const [flashStates, setFlashStates] = useState({});
            
            const wsRef = useRef(null);
            const prevPricesRef = useRef({});

            const ETH_AMOUNT = 20;
            const SOL_AMOUNT = 400;
            const FEE_RATE = 0.0005;

            const triggerFlash = (field, direction) => {
                setFlashStates(prev => ({ ...prev, [field]: direction }));
                setTimeout(() => {
                    setFlashStates(prev => ({ ...prev, [field]: null }));
                }, 400);
            };

            const fetchHourlyCandles = async () => {
                try {
                    const allCandles = { 'KRW-ETH': [], 'KRW-SOL': [] };
                    
                    for (const market of ['KRW-ETH', 'KRW-SOL']) {
                        const response = await fetch(`https://api.upbit.com/v1/candles/minutes/60?market=${market}&count=168`);
                        if (response.ok) {
                            const data = await response.json();
                            allCandles[market] = data;
                            await new Promise(r => setTimeout(r, 100));
                        }
                    }

                    const candleData = [];
                    const hourlyTable = [];
                    const minLen = Math.min(allCandles['KRW-ETH'].length, allCandles['KRW-SOL'].length);
                    
                    for (let i = minLen - 1; i >= 0; i--) {
                        const eth = allCandles['KRW-ETH'][i];
                        const sol = allCandles['KRW-SOL'][i];
                        
                        const diff = eth.trade_price * ETH_AMOUNT - sol.trade_price * SOL_AMOUNT;
                        const timestamp = new Date(eth.candle_date_time_kst).getTime();
                        
                        candleData.push({
                            x: timestamp,
                            o: eth.opening_price * ETH_AMOUNT - sol.opening_price * SOL_AMOUNT,
                            c: diff
                        });

                        // 24시간 이내 데이터만 테이블에 추가
                        if (Date.now() - timestamp < 24 * 60 * 60 * 1000) {
                            hourlyTable.push({
                                timestamp,
                                diff
                            });
                        }
                    }

                    setChartData(candleData);
                    setHourlyData(hourlyTable.reverse().slice(0, 24));
                    await fetchStats(allCandles);
                    
                } catch (error) {
                    console.error('Error:', error);
                }
            };

            const fetchStats = async (hourlyData) => {
                try {
                    const allMinutes = { 'KRW-ETH': [], 'KRW-SOL': [] };
                    
                    for (const market of ['KRW-ETH', 'KRW-SOL']) {
                        for (let i = 0; i < 8; i++) {
                            const to = new Date(Date.now() - (i * 200 * 60 * 1000)).toISOString();
                            const response = await fetch(`https://api.upbit.com/v1/candles/minutes/1?market=${market}&to=${to}&count=200`);
                            if (response.ok) {
                                const data = await response.json();
                                allMinutes[market].push(...data);
                                await new Promise(r => setTimeout(r, 100));
                            }
                        }
                    }

                    const calc = (ethCandles, solCandles, timeLimit) => {
                        const now = Date.now();
                        const filtered = ethCandles.map((eth, idx) => {
                            const sol = solCandles[idx];
                            if (!sol) return null;
                            const ts = new Date(eth.candle_date_time_kst).getTime();
                            if (ts < now - timeLimit) return null;
                            return { 
                                diff: eth.trade_price * ETH_AMOUNT - sol.trade_price * SOL_AMOUNT,
                                timestamp: ts 
                            };
                        }).filter(Boolean);

                        if (!filtered.length) return null;
                        const sorted = [...filtered].sort((a, b) => a.diff - b.diff);
                        return { min: sorted[0], max: sorted[sorted.length - 1] };
                    };

                    setStats24h(calc(allMinutes['KRW-ETH'], allMinutes['KRW-SOL'], 24 * 60 * 60 * 1000));
                    setStats7d(calc(hourlyData['KRW-ETH'], hourlyData['KRW-SOL'], 7 * 24 * 60 * 60 * 1000));
                    
                } catch (error) {
                    console.error('Stats error:', error);
                }
            };

            const fetchDayChanges = async () => {
                try {
                    const response = await fetch('https://api.upbit.com/v1/ticker?markets=KRW-ETH,KRW-SOL,KRW-BTC');
                    const data = await response.json();
                    const changes = {};
                    data.forEach(item => {
                        const symbol = item.market.replace('KRW-', '').toLowerCase();
                        changes[symbol] = item.signed_change_rate * 100;
                    });
                    setDayChanges(changes);
                } catch (error) {
                    console.error('Error:', error);
                }
            };

            useEffect(() => {
                fetchDayChanges();
                fetchHourlyCandles();

                const ws = new WebSocket('wss://api.upbit.com/websocket/v1');
                wsRef.current = ws;

                ws.onopen = () => {
                    ws.send(JSON.stringify([
                        { ticket: 'tracker' },
                        { type: 'ticker', codes: ['KRW-ETH', 'KRW-SOL', 'KRW-BTC'] }
                    ]));
                    setLoading(false);
                };

                ws.onmessage = async (event) => {
                    const text = await event.data.text();
                    const data = JSON.parse(text);

                    if (data.type === 'ticker') {
                        const symbol = data.code.replace('KRW-', '').toLowerCase();
                        const price = data.trade_price;

                        setPrices(prev => {
                            const newPrices = { ...prev, [symbol]: price };
                            
                            if (prevPricesRef.current[symbol]) {
                                const dir = price > prevPricesRef.current[symbol] ? 'up' : 'down';
                                triggerFlash(symbol, dir);
                                
                                if (symbol === 'eth' || symbol === 'sol') {
                                    const oldDiff = (prevPricesRef.current.eth || 0) * ETH_AMOUNT - (prevPricesRef.current.sol || 0) * SOL_AMOUNT;
                                    const newDiff = (newPrices.eth || 0) * ETH_AMOUNT - (newPrices.sol || 0) * SOL_AMOUNT;
                                    if (oldDiff !== newDiff) {
                                        triggerFlash('difference', newDiff > oldDiff ? 'up' : 'down');
                                    }
                                }
                            }
                            
                            prevPricesRef.current = newPrices;
                            return newPrices;
                        });
                    }
                };

                const int1 = setInterval(fetchHourlyCandles, 10 * 60 * 1000);
                const int2 = setInterval(fetchDayChanges, 60 * 1000);

                return () => {
                    ws.close();
                    clearInterval(int1);
                    clearInterval(int2);
                };
            }, []);

            if (loading || !prices.eth || !prices.sol || !prices.btc) {
                return <div className="loading">데이터 로딩중...</div>;
            }

            const fmt = (num) => Math.round(num).toLocaleString('ko-KR');
            const fmtTime = (ts) => {
                const d = new Date(ts);
                return `${d.getMonth()+1}/${d.getDate()} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
            };

            const ethTotal = prices.eth * ETH_AMOUNT;
            const solTotal = prices.sol * SOL_AMOUNT;
            const diff = ethTotal - solTotal;
            const totalFee = solTotal * FEE_RATE * 2;

            return (
                <div className="container">
                    <div className="header">
                        <div>
                            <h1>UPBIT 스프레드 트레이딩 콘솔</h1>
                            <div className="subtitle">SOL 400 매도 → ETH 매수 → ETH 매도 → SOL 400 재매수 후 KRW 잔여 수익 추적</div>
                        </div>
                        <div className="header-pill">LIVE ARB DESK</div>
                    </div>

                    <div className="main-grid">
                        <div className="card">
                            <div className="card-title">실시간 가격</div>
                            <div className="coin-grid">
                                <div className="coin-item">
                                    <div className="coin-name">BTC</div>
                                    <div className={`coin-price ${flashStates.btc ? `flash-${flashStates.btc}` : ''}`}>
                                        ₩{fmt(prices.btc)}
                                    </div>
                                    <div className={`coin-change ${dayChanges.btc >= 0 ? 'change-positive' : 'change-negative'}`}>
                                        {dayChanges.btc >= 0 ? '+' : ''}{dayChanges.btc.toFixed(2)}%
                                    </div>
                                </div>
                                <div className="coin-item">
                                    <div className="coin-name">ETH</div>
                                    <div className={`coin-price ${flashStates.eth ? `flash-${flashStates.eth}` : ''}`}>
                                        ₩{fmt(prices.eth)}
                                    </div>
                                    <div className={`coin-change ${dayChanges.eth >= 0 ? 'change-positive' : 'change-negative'}`}>
                                        {dayChanges.eth >= 0 ? '+' : ''}{dayChanges.eth.toFixed(2)}%
                                    </div>
                                </div>
                                <div className="coin-item">
                                    <div className="coin-name">SOL</div>
                                    <div className={`coin-price ${flashStates.sol ? `flash-${flashStates.sol}` : ''}`}>
                                        ₩{fmt(prices.sol)}
                                    </div>
                                    <div className={`coin-change ${dayChanges.sol >= 0 ? 'change-positive' : 'change-negative'}`}>
                                        {dayChanges.sol >= 0 ? '+' : ''}{dayChanges.sol.toFixed(2)}%
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div className="card difference-card">
                            <div className="card-title">가격 차이</div>
                            <div className={`diff-value ${flashStates.difference ? `flash-${flashStates.difference}` : ''} ${diff >= 0 ? 'change-positive' : 'change-negative'}`}>
                                {diff >= 0 ? '+' : ''}₩{fmt(diff)}
                            </div>
                            <div className="diff-label">ETH 20개 - SOL 400개</div>
                        </div>

                        <div className="card">
                            <div className="card-title">SOL 거래수수료</div>
                            <div className="fee-grid">
                                <div className="fee-item">
                                    <span className="fee-label">매수</span>
                                    <span className="fee-value">₩{fmt(solTotal * FEE_RATE)}</span>
                                </div>
                                <div className="fee-item">
                                    <span className="fee-label">매도</span>
                                    <span className="fee-value">₩{fmt(solTotal * FEE_RATE)}</span>
                                </div>
                                <div className="fee-item fee-total">
                                    <span className="fee-label">총합</span>
                                    <span className="fee-value">₩{fmt(totalFee)}</span>
                                </div>
                            </div>
                        </div>

                        <div className="card">
                            <div className="card-title">포지션 정보</div>
                            <div className="fee-grid">
                                <div className="fee-item">
                                    <span className="fee-label">ETH 20개</span>
                                    <span className="fee-value">₩{fmt(ethTotal)}</span>
                                </div>
                                <div className="fee-item">
                                    <span className="fee-label">SOL 400개</span>
                                    <span className="fee-value">₩{fmt(solTotal)}</span>
                                </div>
                                <div className="fee-item">
                                    <span className="fee-label">24h 변동폭</span>
                                    <span className="fee-value">
                                        ₩{fmt(stats24h ? Math.abs(stats24h.max.diff - stats24h.min.diff) : 0)}
                                    </span>
                                </div>
                            </div>
                        </div>

                        <div className="card stats-card">
                            <div className="card-title">24시간 통계</div>
                            {stats24h ? (
                                <>
                                    <div className="stat-period">최대 차이</div>
                                    <div className="stat-row">
                                        <span className={`stat-value ${stats24h.max.diff >= 0 ? 'change-positive' : 'change-negative'}`}>
                                            {stats24h.max.diff >= 0 ? '+' : ''}₩{fmt(stats24h.max.diff)}
                                        </span>
                                        <span className="stat-time">{fmtTime(stats24h.max.timestamp)}</span>
                                    </div>
                                    <div className="stat-period" style={{marginTop: '0.5rem'}}>최소 차이</div>
                                    <div className="stat-row">
                                        <span className={`stat-value ${stats24h.min.diff >= 0 ? 'change-positive' : 'change-negative'}`}>
                                            {stats24h.min.diff >= 0 ? '+' : ''}₩{fmt(stats24h.min.diff)}
                                        </span>
                                        <span className="stat-time">{fmtTime(stats24h.min.timestamp)}</span>
                                    </div>
                                </>
                            ) : <div style={{color: 'var(--text-secondary)', fontSize: '0.7rem'}}>로딩중...</div>}
                        </div>

                        <div className="card stats-card">
                            <div className="card-title">7일 통계</div>
                            {stats7d ? (
                                <>
                                    <div className="stat-period">최대 차이</div>
                                    <div className="stat-row">
                                        <span className={`stat-value ${stats7d.max.diff >= 0 ? 'change-positive' : 'change-negative'}`}>
                                            {stats7d.max.diff >= 0 ? '+' : ''}₩{fmt(stats7d.max.diff)}
                                        </span>
                                        <span className="stat-time">{fmtTime(stats7d.max.timestamp)}</span>
                                    </div>
                                    <div className="stat-period" style={{marginTop: '0.5rem'}}>최소 차이</div>
                                    <div className="stat-row">
                                        <span className={`stat-value ${stats7d.min.diff >= 0 ? 'change-positive' : 'change-negative'}`}>
                                            {stats7d.min.diff >= 0 ? '+' : ''}₩{fmt(stats7d.min.diff)}
                                        </span>
                                        <span className="stat-time">{fmtTime(stats7d.min.timestamp)}</span>
                                    </div>
                                </>
                            ) : <div style={{color: 'var(--text-secondary)', fontSize: '0.7rem'}}>로딩중...</div>}
                        </div>

                        <div className="card chart-card">
                            <div className="card-title">7일 가격차이 변동 (1시간봉)</div>
                            <div className="chart-info">
                                {hoverData ? (
                                    <>
                                        <div className="chart-info-item">
                                            <span className="chart-info-label">시간:</span>
                                            <span className="chart-info-value">
                                                {new Date(hoverData.x).toLocaleString('ko-KR', { month: 'numeric', day: 'numeric', hour: '2-digit', minute: '2-digit' })}
                                            </span>
                                        </div>
                                        <div className="chart-info-item">
                                            <span className="chart-info-label">시가:</span>
                                            <span className="chart-info-value">₩{fmt(hoverData.o)}</span>
                                        </div>
                                        <div className="chart-info-item">
                                            <span className="chart-info-label">종가:</span>
                                            <span className="chart-info-value">₩{fmt(hoverData.c)}</span>
                                        </div>
                                    </>
                                ) : (
                                    <span className="chart-info-placeholder">차트에 마우스를 올려 상세 정보 확인</span>
                                )}
                            </div>
                            <div className="chart-container">
                                {chartData.length > 0 ? (
                                    <CandlestickChart data={chartData} onHover={setHoverData} />
                                ) : (
                                    <div style={{padding: '1rem', color: 'var(--text-secondary)', fontSize: '0.7rem'}}>차트 로딩중...</div>
                                )}
                            </div>
                        </div>
                    </div>

                    <div className="status">
                        <div className="status-dot"></div>
                        <span>실시간 WebSocket</span>
                        <span>•</span>
                        <span>{chartData.length}개 봉</span>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
