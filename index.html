<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>솔라나-이더리움 가격 추적기</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0a0a0f;
            --bg-card: #13131a;
            --accent-green: #00ff88;
            --accent-red: #ff3366;
            --accent-blue: #00d4ff;
            --accent-yellow: #ffd600;
            --text-primary: #ffffff;
            --text-secondary: #8a8a9f;
            --border: #2a2a35;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg);
            color: var(--text-primary);
            overflow-x: hidden;
        }

        .container {
            padding: 1rem;
            max-width: 1600px;
            margin: 0 auto;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            text-align: center;
            margin-bottom: 0.75rem;
        }

        h1 {
            font-size: 1.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, #9945ff, var(--accent-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.25rem;
        }

        .subtitle {
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        .main-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.75rem;
            flex: 1;
            overflow: hidden;
        }

        .card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.75rem;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .card-title {
            font-size: 0.65rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .coin-grid {
            display: grid;
            gap: 0.5rem;
            flex: 1;
        }

        .coin-item {
            background: rgba(255, 255, 255, 0.03);
            padding: 0.5rem;
            border-radius: 6px;
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 0.5rem;
            align-items: center;
        }

        .coin-name {
            font-size: 0.7rem;
            font-weight: 700;
            color: var(--text-secondary);
        }

        .coin-price {
            font-size: 0.85rem;
            font-weight: 700;
            text-align: right;
            transition: all 0.15s ease;
        }

        .coin-price.flash-up {
            animation: flashUp 0.4s ease;
        }

        .coin-price.flash-down {
            animation: flashDown 0.4s ease;
        }

        @keyframes flashUp {
            0% { color: var(--text-primary); transform: scale(1); }
            50% { 
                color: var(--accent-red); 
                transform: scale(1.1);
                text-shadow: 0 0 10px var(--accent-red);
            }
            100% { color: var(--text-primary); transform: scale(1); }
        }

        @keyframes flashDown {
            0% { color: var(--text-primary); transform: scale(1); }
            50% { 
                color: var(--accent-blue); 
                transform: scale(1.1);
                text-shadow: 0 0 10px var(--accent-blue);
            }
            100% { color: var(--text-primary); transform: scale(1); }
        }

        .coin-change {
            font-size: 0.65rem;
            font-weight: 600;
            padding: 0.15rem 0.35rem;
            border-radius: 3px;
            white-space: nowrap;
        }

        .change-positive {
            background: rgba(0, 255, 136, 0.15);
            color: var(--accent-green);
        }

        .change-negative {
            background: rgba(255, 51, 102, 0.15);
            color: var(--accent-red);
        }

        .difference-card {
            background: linear-gradient(135deg, #1a1a25 0%, #25252f 100%);
            border: 2px solid #9945ff;
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .diff-value {
            font-size: 1.8rem;
            font-weight: 800;
            margin-bottom: 0.25rem;
            transition: all 0.15s ease;
        }

        .diff-value.flash-up {
            animation: flashUp 0.4s ease;
        }

        .diff-value.flash-down {
            animation: flashDown 0.4s ease;
        }

        .diff-label {
            font-size: 0.65rem;
            color: var(--text-secondary);
        }

        .fee-grid {
            display: grid;
            gap: 0.4rem;
        }

        .fee-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.4rem;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 4px;
        }

        .fee-label {
            font-size: 0.65rem;
            color: var(--text-secondary);
        }

        .fee-value {
            font-size: 0.75rem;
            font-weight: 700;
        }

        .fee-total {
            background: rgba(255, 214, 0, 0.1);
            border-left: 2px solid var(--accent-yellow);
        }

        .stats-card {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .stat-period {
            font-size: 0.65rem;
            color: #9945ff;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.25rem;
        }

        .stat-row {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.3rem;
            padding: 0.4rem;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 4px;
        }

        .stat-value {
            font-size: 0.85rem;
            font-weight: 700;
        }

        .stat-time {
            font-size: 0.55rem;
            color: var(--text-secondary);
        }

        .chart-card {
            grid-column: 1 / -1;
            min-height: 0;
        }

        .chart-info {
            display: flex;
            gap: 1.5rem;
            padding: 0.5rem 0;
            margin-bottom: 0.5rem;
            font-size: 0.75rem;
            border-bottom: 1px solid var(--border);
            min-height: 28px;
        }

        .chart-info-item {
            display: flex;
            gap: 0.5rem;
        }

        .chart-info-label {
            color: var(--text-secondary);
        }

        .chart-info-value {
            font-weight: 700;
            color: var(--text-primary);
        }

        .chart-info-placeholder {
            color: var(--text-secondary);
            font-size: 0.7rem;
        }

        .chart-container {
            position: relative;
            flex: 1;
            min-height: 0;
            touch-action: none;
        }

        .chart-svg {
            width: 100%;
            height: 100%;
            min-height: 200px;
            touch-action: none;
        }

        .crosshair-line {
            pointer-events: none;
        }

        .status {
            position: fixed;
            bottom: 0.5rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 0.75rem;
            align-items: center;
            padding: 0.4rem 0.75rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 20px;
            font-size: 0.6rem;
            color: var(--text-secondary);
            z-index: 1000;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--accent-green);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 0.5rem;
                height: auto;
                min-height: 100vh;
            }
            
            h1 {
                font-size: 1.2rem;
            }
            
            .main-grid {
                grid-template-columns: 1fr;
                gap: 0.5rem;
            }
            
            .card {
                padding: 0.6rem;
            }
            
            .diff-value {
                font-size: 1.4rem;
            }

            .chart-card {
                margin: 0 -0.5rem;
                width: calc(100% + 1rem);
                border-radius: 0;
            }

            .chart-svg {
                min-height: 250px;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function CandlestickChart({ data, onHover }) {
            const svgRef = useRef(null);
            const containerRef = useRef(null);
            const [isTouching, setIsTouching] = useState(false);

            useEffect(() => {
                if (!data || data.length === 0 || !svgRef.current || !containerRef.current) return;

                const container = containerRef.current;
                const svg = svgRef.current;
                const width = container.clientWidth;
                const height = 300;
                
                svg.innerHTML = '';
                svg.setAttribute('width', width);
                svg.setAttribute('height', height);
                svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

                const isMobile = width < 768;
                const padding = isMobile 
                    ? { top: 20, right: 10, bottom: 60, left: 10 }
                    : { top: 20, right: 50, bottom: 50, left: 60 };
                
                const chartWidth = width - padding.left - padding.right;
                const chartHeight = height - padding.top - padding.bottom;

                const allValues = data.flatMap(d => [d.o, d.c]);
                const minValue = Math.min(...allValues);
                const maxValue = Math.max(...allValues);
                const valueRange = maxValue - minValue;

                const yScale = (value) => {
                    return padding.top + chartHeight - ((value - minValue) / valueRange) * chartHeight;
                };

                const candleWidth = Math.max(2, chartWidth / data.length * 0.8);
                const candleGap = chartWidth / data.length;

                // Y축 그리드
                const gridCount = isMobile ? 4 : 5;
                for (let i = 0; i <= gridCount; i++) {
                    const y = padding.top + (chartHeight / gridCount) * i;
                    const value = maxValue - (valueRange / gridCount) * i;
                    
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', padding.left);
                    line.setAttribute('y1', y);
                    line.setAttribute('x2', width - padding.right);
                    line.setAttribute('y2', y);
                    line.setAttribute('stroke', 'rgba(255,255,255,0.05)');
                    svg.appendChild(line);

                    if (!isMobile) {
                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('x', width - padding.right + 5);
                        text.setAttribute('y', y + 4);
                        text.setAttribute('fill', '#8a8a9f');
                        text.setAttribute('font-size', '10');
                        text.textContent = '₩' + Math.round(value).toLocaleString();
                        svg.appendChild(text);
                    }
                }

                // X축 날짜 라벨
                const dateMap = new Map();
                data.forEach((candle, i) => {
                    const date = new Date(candle.x);
                    const dateKey = `${date.getMonth()+1}/${date.getDate()}`;
                    
                    if (!dateMap.has(dateKey)) {
                        dateMap.set(dateKey, i);
                    }
                });

                // 모바일에서는 날짜 간격을 넓게
                const dateEntries = Array.from(dateMap.entries());
                const dateStep = isMobile ? Math.ceil(dateEntries.length / 4) : 1;
                
                dateEntries.forEach(([dateLabel, index], i) => {
                    if (i % dateStep !== 0 && i !== dateEntries.length - 1) return;
                    
                    const x = padding.left + candleGap * index + candleGap / 2;
                    
                    const dateText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    dateText.setAttribute('x', x);
                    dateText.setAttribute('y', height - padding.bottom + 20);
                    dateText.setAttribute('fill', '#8a8a9f');
                    dateText.setAttribute('font-size', isMobile ? '11' : '10');
                    dateText.setAttribute('text-anchor', 'middle');
                    dateText.textContent = dateLabel;
                    svg.appendChild(dateText);
                    
                    const dateLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    dateLine.setAttribute('x1', x);
                    dateLine.setAttribute('y1', padding.top);
                    dateLine.setAttribute('x2', x);
                    dateLine.setAttribute('y2', height - padding.bottom);
                    dateLine.setAttribute('stroke', 'rgba(255,255,255,0.08)');
                    dateLine.setAttribute('stroke-dasharray', '2,3');
                    svg.appendChild(dateLine);
                });

                // 크로스헤어 라인들
                const verticalLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                verticalLine.setAttribute('stroke', '#9945ff');
                verticalLine.setAttribute('stroke-width', isMobile ? '2' : '1');
                verticalLine.setAttribute('stroke-dasharray', '4,4');
                verticalLine.setAttribute('opacity', '0');
                verticalLine.setAttribute('y1', padding.top);
                verticalLine.setAttribute('y2', height - padding.bottom);
                verticalLine.setAttribute('pointer-events', 'none');
                svg.appendChild(verticalLine);

                const horizontalLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                horizontalLine.setAttribute('stroke', '#9945ff');
                horizontalLine.setAttribute('stroke-width', isMobile ? '2' : '1');
                horizontalLine.setAttribute('stroke-dasharray', '4,4');
                horizontalLine.setAttribute('opacity', '0');
                horizontalLine.setAttribute('x1', padding.left);
                horizontalLine.setAttribute('x2', width - padding.right);
                horizontalLine.setAttribute('pointer-events', 'none');
                svg.appendChild(horizontalLine);

                // 호버 정보 텍스트
                const hoverDateText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                hoverDateText.setAttribute('fill', '#9945ff');
                hoverDateText.setAttribute('font-size', isMobile ? '12' : '11');
                hoverDateText.setAttribute('font-weight', '700');
                hoverDateText.setAttribute('text-anchor', 'middle');
                hoverDateText.setAttribute('opacity', '0');
                hoverDateText.setAttribute('y', height - padding.bottom + 45);
                hoverDateText.setAttribute('pointer-events', 'none');
                svg.appendChild(hoverDateText);

                if (!isMobile) {
                    const priceText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    priceText.setAttribute('fill', '#9945ff');
                    priceText.setAttribute('font-size', '11');
                    priceText.setAttribute('font-weight', '700');
                    priceText.setAttribute('text-anchor', 'end');
                    priceText.setAttribute('opacity', '0');
                    priceText.setAttribute('x', padding.left - 5);
                    priceText.setAttribute('pointer-events', 'none');
                    svg.appendChild(priceText);
                }

                // 크로스헤어 업데이트 함수
                const updateCrosshair = (clientX) => {
                    const rect = svg.getBoundingClientRect();
                    const x = clientX - rect.left;
                    
                    if (x < padding.left || x > width - padding.right) {
                        return;
                    }

                    const index = Math.floor((x - padding.left) / candleGap);
                    if (index < 0 || index >= data.length) return;

                    const candle = data[index];
                    const candleX = padding.left + candleGap * index + candleGap / 2;
                    const yClose = yScale(candle.c);

                    verticalLine.setAttribute('x1', candleX);
                    verticalLine.setAttribute('x2', candleX);
                    verticalLine.setAttribute('opacity', '0.8');

                    horizontalLine.setAttribute('y1', yClose);
                    horizontalLine.setAttribute('y2', yClose);
                    horizontalLine.setAttribute('opacity', '0.8');

                    const date = new Date(candle.x);
                    hoverDateText.textContent = `${date.getMonth()+1}/${date.getDate()} ${String(date.getHours()).padStart(2,'0')}:00 - ₩${Math.round(candle.c).toLocaleString()}`;
                    hoverDateText.setAttribute('x', width / 2);
                    hoverDateText.setAttribute('opacity', '1');

                    if (!isMobile && svg.querySelector('text[text-anchor="end"]')) {
                        const priceText = svg.querySelector('text[text-anchor="end"]');
                        priceText.textContent = '₩' + Math.round(candle.c).toLocaleString();
                        priceText.setAttribute('y', yClose + 4);
                        priceText.setAttribute('opacity', '1');
                    }

                    onHover(candle);
                };

                const hideCrosshair = () => {
                    verticalLine.setAttribute('opacity', '0');
                    horizontalLine.setAttribute('opacity', '0');
                    hoverDateText.setAttribute('opacity', '0');
                    if (!isMobile && svg.querySelector('text[text-anchor="end"]')) {
                        svg.querySelector('text[text-anchor="end"]').setAttribute('opacity', '0');
                    }
                    onHover(null);
                };

                // 캔들 그리기
                data.forEach((candle, i) => {
                    const x = padding.left + candleGap * i + (candleGap - candleWidth) / 2;
                    const yOpen = yScale(candle.o);
                    const yClose = yScale(candle.c);

                    const isUp = candle.c >= candle.o;
                    const color = isUp ? '#00ff88' : '#ff3366';

                    const bodyHeight = Math.abs(yClose - yOpen) || 1;
                    const bodyY = Math.min(yOpen, yClose);
                    
                    const body = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    body.setAttribute('x', x);
                    body.setAttribute('y', bodyY);
                    body.setAttribute('width', candleWidth);
                    body.setAttribute('height', bodyHeight);
                    body.setAttribute('fill', color);
                    body.setAttribute('pointer-events', 'none');
                    svg.appendChild(body);
                });

                // 투명 오버레이
                const overlay = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                overlay.setAttribute('x', 0);
                overlay.setAttribute('y', 0);
                overlay.setAttribute('width', width);
                overlay.setAttribute('height', height);
                overlay.setAttribute('fill', 'transparent');
                overlay.setAttribute('cursor', 'crosshair');

                // 마우스 이벤트
                overlay.addEventListener('mouseenter', (e) => {
                    if (!isMobile) updateCrosshair(e.clientX);
                });

                overlay.addEventListener('mousemove', (e) => {
                    if (!isMobile) updateCrosshair(e.clientX);
                });

                overlay.addEventListener('mouseleave', () => {
                    if (!isTouching && !isMobile) hideCrosshair();
                });

                // 터치 이벤트
                overlay.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    setIsTouching(true);
                    const touch = e.touches[0];
                    updateCrosshair(touch.clientX);
                }, { passive: false });

                overlay.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    updateCrosshair(touch.clientX);
                }, { passive: false });

                overlay.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    setTimeout(() => {
                        setIsTouching(false);
                        hideCrosshair();
                    }, 1500);
                }, { passive: false });

                overlay.addEventListener('touchcancel', () => {
                    setIsTouching(false);
                    hideCrosshair();
                });

                svg.appendChild(overlay);

            }, [data, onHover, isTouching]);

            return (
                <div ref={containerRef} style={{ width: '100%', height: '100%', minHeight: '300px' }}>
                    <svg ref={svgRef} className="chart-svg" style={{ display: 'block' }}></svg>
                </div>
            );
        }

        function App() {
            const [prices, setPrices] = useState({ eth: null, sol: null, btc: null });
            const [dayChanges, setDayChanges] = useState({ eth: 0, sol: 0, btc: 0 });
            const [stats24h, setStats24h] = useState(null);
            const [stats7d, setStats7d] = useState(null);
            const [chartData, setChartData] = useState([]);
            const [hourlyData, setHourlyData] = useState([]);
            const [hoverData, setHoverData] = useState(null);
            const [loading, setLoading] = useState(true);
            const [flashStates, setFlashStates] = useState({});
            
            const wsRef = useRef(null);
            const prevPricesRef = useRef({});

            const ETH_AMOUNT = 20;
            const SOL_AMOUNT = 400;
            const FEE_RATE = 0.0005;

            const triggerFlash = (field, direction) => {
                setFlashStates(prev => ({ ...prev, [field]: direction }));
                setTimeout(() => {
                    setFlashStates(prev => ({ ...prev, [field]: null }));
                }, 400);
            };

            const fetchHourlyCandles = async () => {
                try {
                    const allCandles = { 'KRW-ETH': [], 'KRW-SOL': [] };
                    
                    for (const market of ['KRW-ETH', 'KRW-SOL']) {
                        const response = await fetch(`https://api.upbit.com/v1/candles/minutes/60?market=${market}&count=168`);
                        if (response.ok) {
                            const data = await response.json();
                            allCandles[market] = data;
                            await new Promise(r => setTimeout(r, 100));
                        }
                    }

                    const candleData = [];
                    const hourlyTable = [];
                    const minLen = Math.min(allCandles['KRW-ETH'].length, allCandles['KRW-SOL'].length);
                    
                    for (let i = minLen - 1; i >= 0; i--) {
                        const eth = allCandles['KRW-ETH'][i];
                        const sol = allCandles['KRW-SOL'][i];
                        
                        const diff = eth.trade_price * ETH_AMOUNT - sol.trade_price * SOL_AMOUNT;
                        const timestamp = new Date(eth.candle_date_time_kst).getTime();
                        
                        candleData.push({
                            x: timestamp,
                            o: eth.opening_price * ETH_AMOUNT - sol.opening_price * SOL_AMOUNT,
                            c: diff
                        });

                        // 24시간 이내 데이터만 테이블에 추가
                        if (Date.now() - timestamp < 24 * 60 * 60 * 1000) {
                            hourlyTable.push({
                                timestamp,
                                diff
                            });
                        }
                    }

                    setChartData(candleData);
                    setHourlyData(hourlyTable.reverse().slice(0, 24));
                    await fetchStats(allCandles);
                    
                } catch (error) {
                    console.error('Error:', error);
                }
            };

            const fetchStats = async (hourlyData) => {
                try {
                    const allMinutes = { 'KRW-ETH': [], 'KRW-SOL': [] };
                    
                    for (const market of ['KRW-ETH', 'KRW-SOL']) {
                        for (let i = 0; i < 8; i++) {
                            const to = new Date(Date.now() - (i * 200 * 60 * 1000)).toISOString();
                            const response = await fetch(`https://api.upbit.com/v1/candles/minutes/1?market=${market}&to=${to}&count=200`);
                            if (response.ok) {
                                const data = await response.json();
                                allMinutes[market].push(...data);
                                await new Promise(r => setTimeout(r, 100));
                            }
                        }
                    }

                    const calc = (ethCandles, solCandles, timeLimit) => {
                        const now = Date.now();
                        const filtered = ethCandles.map((eth, idx) => {
                            const sol = solCandles[idx];
                            if (!sol) return null;
                            const ts = new Date(eth.candle_date_time_kst).getTime();
                            if (ts < now - timeLimit) return null;
                            return { 
                                diff: eth.trade_price * ETH_AMOUNT - sol.trade_price * SOL_AMOUNT,
                                timestamp: ts 
                            };
                        }).filter(Boolean);

                        if (!filtered.length) return null;
                        const sorted = [...filtered].sort((a, b) => a.diff - b.diff);
                        return { min: sorted[0], max: sorted[sorted.length - 1] };
                    };

                    setStats24h(calc(allMinutes['KRW-ETH'], allMinutes['KRW-SOL'], 24 * 60 * 60 * 1000));
                    setStats7d(calc(hourlyData['KRW-ETH'], hourlyData['KRW-SOL'], 7 * 24 * 60 * 60 * 1000));
                    
                } catch (error) {
                    console.error('Stats error:', error);
                }
            };

            const fetchDayChanges = async () => {
                try {
                    const response = await fetch('https://api.upbit.com/v1/ticker?markets=KRW-ETH,KRW-SOL,KRW-BTC');
                    const data = await response.json();
                    const changes = {};
                    data.forEach(item => {
                        const symbol = item.market.replace('KRW-', '').toLowerCase();
                        changes[symbol] = item.signed_change_rate * 100;
                    });
                    setDayChanges(changes);
                } catch (error) {
                    console.error('Error:', error);
                }
            };

            useEffect(() => {
                fetchDayChanges();
                fetchHourlyCandles();

                const ws = new WebSocket('wss://api.upbit.com/websocket/v1');
                wsRef.current = ws;

                ws.onopen = () => {
                    ws.send(JSON.stringify([
                        { ticket: 'tracker' },
                        { type: 'ticker', codes: ['KRW-ETH', 'KRW-SOL', 'KRW-BTC'] }
                    ]));
                    setLoading(false);
                };

                ws.onmessage = async (event) => {
                    const text = await event.data.text();
                    const data = JSON.parse(text);

                    if (data.type === 'ticker') {
                        const symbol = data.code.replace('KRW-', '').toLowerCase();
                        const price = data.trade_price;

                        setPrices(prev => {
                            const newPrices = { ...prev, [symbol]: price };
                            
                            if (prevPricesRef.current[symbol]) {
                                const dir = price > prevPricesRef.current[symbol] ? 'up' : 'down';
                                triggerFlash(symbol, dir);
                                
                                if (symbol === 'eth' || symbol === 'sol') {
                                    const oldDiff = (prevPricesRef.current.eth || 0) * ETH_AMOUNT - (prevPricesRef.current.sol || 0) * SOL_AMOUNT;
                                    const newDiff = (newPrices.eth || 0) * ETH_AMOUNT - (newPrices.sol || 0) * SOL_AMOUNT;
                                    if (oldDiff !== newDiff) {
                                        triggerFlash('difference', newDiff > oldDiff ? 'up' : 'down');
                                    }
                                }
                            }
                            
                            prevPricesRef.current = newPrices;
                            return newPrices;
                        });
                    }
                };

                const int1 = setInterval(fetchHourlyCandles, 10 * 60 * 1000);
                const int2 = setInterval(fetchDayChanges, 60 * 1000);

                return () => {
                    ws.close();
                    clearInterval(int1);
                    clearInterval(int2);
                };
            }, []);

            if (loading || !prices.eth || !prices.sol || !prices.btc) {
                return <div className="loading">데이터 로딩중...</div>;
            }

            const fmt = (num) => Math.round(num).toLocaleString('ko-KR');
            const fmtTime = (ts) => {
                const d = new Date(ts);
                return `${d.getMonth()+1}/${d.getDate()} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
            };

            const ethTotal = prices.eth * ETH_AMOUNT;
            const solTotal = prices.sol * SOL_AMOUNT;
            const diff = ethTotal - solTotal;
            const totalFee = solTotal * FEE_RATE * 2;

            return (
                <div className="container">
                    <div className="header">
                        <h1>솔라나-이더리움 가격 추적기</h1>
                        <div className="subtitle">ETH 20개 vs SOL 400개 + BTC</div>
                    </div>

                    <div className="main-grid">
                        <div className="card">
                            <div className="card-title">실시간 가격</div>
                            <div className="coin-grid">
                                <div className="coin-item">
                                    <div className="coin-name">BTC</div>
                                    <div className={`coin-price ${flashStates.btc ? `flash-${flashStates.btc}` : ''}`}>
                                        ₩{fmt(prices.btc)}
                                    </div>
                                    <div className={`coin-change ${dayChanges.btc >= 0 ? 'change-positive' : 'change-negative'}`}>
                                        {dayChanges.btc >= 0 ? '+' : ''}{dayChanges.btc.toFixed(2)}%
                                    </div>
                                </div>
                                <div className="coin-item">
                                    <div className="coin-name">ETH</div>
                                    <div className={`coin-price ${flashStates.eth ? `flash-${flashStates.eth}` : ''}`}>
                                        ₩{fmt(prices.eth)}
                                    </div>
                                    <div className={`coin-change ${dayChanges.eth >= 0 ? 'change-positive' : 'change-negative'}`}>
                                        {dayChanges.eth >= 0 ? '+' : ''}{dayChanges.eth.toFixed(2)}%
                                    </div>
                                </div>
                                <div className="coin-item">
                                    <div className="coin-name">SOL</div>
                                    <div className={`coin-price ${flashStates.sol ? `flash-${flashStates.sol}` : ''}`}>
                                        ₩{fmt(prices.sol)}
                                    </div>
                                    <div className={`coin-change ${dayChanges.sol >= 0 ? 'change-positive' : 'change-negative'}`}>
                                        {dayChanges.sol >= 0 ? '+' : ''}{dayChanges.sol.toFixed(2)}%
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div className="card difference-card">
                            <div className="card-title">가격 차이</div>
                            <div className={`diff-value ${flashStates.difference ? `flash-${flashStates.difference}` : ''} ${diff >= 0 ? 'change-positive' : 'change-negative'}`}>
                                {diff >= 0 ? '+' : ''}₩{fmt(diff)}
                            </div>
                            <div className="diff-label">ETH 20개 - SOL 400개</div>
                        </div>

                        <div className="card">
                            <div className="card-title">SOL 거래수수료</div>
                            <div className="fee-grid">
                                <div className="fee-item">
                                    <span className="fee-label">매수</span>
                                    <span className="fee-value">₩{fmt(solTotal * FEE_RATE)}</span>
                                </div>
                                <div className="fee-item">
                                    <span className="fee-label">매도</span>
                                    <span className="fee-value">₩{fmt(solTotal * FEE_RATE)}</span>
                                </div>
                                <div className="fee-item fee-total">
                                    <span className="fee-label">총합</span>
                                    <span className="fee-value">₩{fmt(totalFee)}</span>
                                </div>
                            </div>
                        </div>

                        <div className="card">
                            <div className="card-title">포지션 정보</div>
                            <div className="fee-grid">
                                <div className="fee-item">
                                    <span className="fee-label">ETH 20개</span>
                                    <span className="fee-value">₩{fmt(ethTotal)}</span>
                                </div>
                                <div className="fee-item">
                                    <span className="fee-label">SOL 400개</span>
                                    <span className="fee-value">₩{fmt(solTotal)}</span>
                                </div>
                                <div className="fee-item">
                                    <span className="fee-label">24h 변동폭</span>
                                    <span className="fee-value">
                                        ₩{fmt(stats24h ? Math.abs(stats24h.max.diff - stats24h.min.diff) : 0)}
                                    </span>
                                </div>
                            </div>
                        </div>

                        <div className="card stats-card">
                            <div className="card-title">24시간 통계</div>
                            {stats24h ? (
                                <>
                                    <div className="stat-period">최대 차이</div>
                                    <div className="stat-row">
                                        <span className={`stat-value ${stats24h.max.diff >= 0 ? 'change-positive' : 'change-negative'}`}>
                                            {stats24h.max.diff >= 0 ? '+' : ''}₩{fmt(stats24h.max.diff)}
                                        </span>
                                        <span className="stat-time">{fmtTime(stats24h.max.timestamp)}</span>
                                    </div>
                                    <div className="stat-period" style={{marginTop: '0.5rem'}}>최소 차이</div>
                                    <div className="stat-row">
                                        <span className={`stat-value ${stats24h.min.diff >= 0 ? 'change-positive' : 'change-negative'}`}>
                                            {stats24h.min.diff >= 0 ? '+' : ''}₩{fmt(stats24h.min.diff)}
                                        </span>
                                        <span className="stat-time">{fmtTime(stats24h.min.timestamp)}</span>
                                    </div>
                                </>
                            ) : <div style={{color: 'var(--text-secondary)', fontSize: '0.7rem'}}>로딩중...</div>}
                        </div>

                        <div className="card stats-card">
                            <div className="card-title">7일 통계</div>
                            {stats7d ? (
                                <>
                                    <div className="stat-period">최대 차이</div>
                                    <div className="stat-row">
                                        <span className={`stat-value ${stats7d.max.diff >= 0 ? 'change-positive' : 'change-negative'}`}>
                                            {stats7d.max.diff >= 0 ? '+' : ''}₩{fmt(stats7d.max.diff)}
                                        </span>
                                        <span className="stat-time">{fmtTime(stats7d.max.timestamp)}</span>
                                    </div>
                                    <div className="stat-period" style={{marginTop: '0.5rem'}}>최소 차이</div>
                                    <div className="stat-row">
                                        <span className={`stat-value ${stats7d.min.diff >= 0 ? 'change-positive' : 'change-negative'}`}>
                                            {stats7d.min.diff >= 0 ? '+' : ''}₩{fmt(stats7d.min.diff)}
                                        </span>
                                        <span className="stat-time">{fmtTime(stats7d.min.timestamp)}</span>
                                    </div>
                                </>
                            ) : <div style={{color: 'var(--text-secondary)', fontSize: '0.7rem'}}>로딩중...</div>}
                        </div>

                        <div className="card chart-card">
                            <div className="card-title">7일 가격차이 변동 (1시간봉)</div>
                            <div className="chart-info">
                                {hoverData ? (
                                    <>
                                        <div className="chart-info-item">
                                            <span className="chart-info-label">시간:</span>
                                            <span className="chart-info-value">
                                                {new Date(hoverData.x).toLocaleString('ko-KR', { month: 'numeric', day: 'numeric', hour: '2-digit', minute: '2-digit' })}
                                            </span>
                                        </div>
                                        <div className="chart-info-item">
                                            <span className="chart-info-label">시가:</span>
                                            <span className="chart-info-value">₩{fmt(hoverData.o)}</span>
                                        </div>
                                        <div className="chart-info-item">
                                            <span className="chart-info-label">종가:</span>
                                            <span className="chart-info-value">₩{fmt(hoverData.c)}</span>
                                        </div>
                                    </>
                                ) : (
                                    <span className="chart-info-placeholder">차트에 마우스를 올려 상세 정보 확인</span>
                                )}
                            </div>
                            <div className="chart-container">
                                {chartData.length > 0 ? (
                                    <CandlestickChart data={chartData} onHover={setHoverData} />
                                ) : (
                                    <div style={{padding: '1rem', color: 'var(--text-secondary)', fontSize: '0.7rem'}}>차트 로딩중...</div>
                                )}
                            </div>
                        </div>
                    </div>

                    <div className="status">
                        <div className="status-dot"></div>
                        <span>실시간 WebSocket</span>
                        <span>•</span>
                        <span>{chartData.length}개 봉</span>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
